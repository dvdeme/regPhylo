% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MultiTopoConst.EditXML4BEAST2.R
\name{MultiTopoConst.EditXML4BEAST2}
\alias{MultiTopoConst.EditXML4BEAST2}
\title{Implements multiple monophyletic constraints in the xml file
for BEASTV2 using a rooted RAxML tree with bootstrap supports.}
\usage{
MultiTopoConst.EditXML4BEAST2(inputtree = NULL, output = NULL,
  bootstrapTH = NULL, xmltreename = NULL, input.xml = NULL,
  Partitions = NULL, TaxaNoDNA = NULL, TaxoTable = NULL,
  output.new.TaxoTable = NULL, output.new.tree = NULL)
}
\arguments{
\item{inputtree}{a rooted phylogenetic tree of class 'phylo' (usually a RAxML tree
already setup with monophyletic constraints) and with Bootstrap values reported
for each node (use Dendroscope 3.5.9 to root the tree to allow proper bootstrap
values to be associated to the proper nodes).}

\item{output}{name of xml file output ready for BEAST analysis
(with the path, if necessary).}

\item{bootstrapTH}{a bootstrap threshold (between [0,100]) used to determine
the node that must be constrained (all nodes with a bootstrap equal or
above the threshold value, will be constrained to form monophyletic groups).}

\item{xmltreename}{name of the xml tree in the input xml file.}

\item{input.xml}{name of the input xml file (with the path, if necessary)
edited by beauti without any topological constraints.}

\item{Partitions}{if 'Yes' indicate the presence of multiple nucleotide partitions in
the alignment.}

\item{TaxaNoDNA}{a three column dataframe (i.e. class "data.frame"), with the species name in
the first column (Species names, without space, '?', '-' or '.'), a second
column with the hierarchical level where the constraint applies ('Family',
'Genus'...), and a third column with the name of the hierarchical constraint
(e.g.  'Aplodactylidae', 'Aplodactylus'). Care should be taken when specifying
the hierarchical level and the name of the constraints which must be present
already in the taxonomic table gathering all the Linnaean classification
information for the taxa with DNA present in the tree. If a dataframe is
provided in the TaxaNoDNA option, then the next three arguments must be
specified.}

\item{TaxoTable}{a classification table of class 'data.frame', the first
column is the species names (or the name used as tip.label by the phylogenetic
tree), then the next columns are the different hierarchical levels of the
Linnaean classification.}

\item{output.new.TaxoTable}{name of the new taxonomic table
(with the path, if necessary) including taxa without DNA.}

\item{output.new.tree}{name of the phylogenetic tree
(with the path, if necessary) that is going to be
exported, including taxa without DNA, in a Newick format.}
}
\value{
An .xml file including all the block related to the constrained taxa.
}
\description{
This function implements multiple monophyletic constraints in the xml file for
BEAST2 using a rooted RAxML tree with bootstrap support. This function allows to
include taxa without DNA in the tree if required. These taxa can be
constrained to move freely within a clade, but the constraints must be
specified in the TaxaNoDNA data.frame, and a taxonomic table must be provided
(similar table that the one used for the function ConstraintTaxo2newick.R).
}
\details{
If the inclusion of a taxon without DNA applies to a clade including subclades
that were constrained in the previous maximum likelihood analysis (RAxML tree),
then those constraints are removed to allow the taxon without DNA to move
freely across the entire diversity of the clade (for instance, if a taxon
without DNA is added in a family X, and the family X contains two genera
already constrained in the Maximum likelihood analysis, then these two
constraints of monophyly will be removed, to allow the taxon without DNA to
also enter within those two genera).
}
\examples{
\dontrun{
# To run the example it might be better to copy the input files
# provided by the package to a temporary directory created into the
# current working directory.

src.dir = system.file("extdata/TopoConstraints", package = "regPhylo")
dir.create("TempDir.TopoConstraints2")
# Set up the path of the TempDir folder.
dest.dir = paste(getwd(), "/TempDir.TopoConstraints2", sep="")
file.names <- dir(src.dir)
# Copy all the files stored in regPhylo/extdata/TopoConstraints"
# into a temporary folder.
sapply(file.names, function(x) {
file.copy(from = paste(src.dir, x, sep = "/"),
to = paste(dest.dir, x, sep = "/"),
overwrite = FALSE) })

# First, we build a tree with RAxML using a guiding tree to constraints
# the topology considering all constraints.

nthread = 5
input = "TempDir.TopoConstraints2/Concat.fas"
output = "Concat_7GTR_Allconst_autoMRE"
ConstraintTree = "TempDir.TopoConstraints2/BackboneTreeAll.txt"
PartitionFile = "TempDir.TopoConstraints2/Partitions_Concat.txt_PF2_all.txt"
a=paste("raxmlHPC-PTHREADS-AVX -g ", ConstraintTree,
" -f a -x 22345 -p 12345 -# autoMRE -q ", PartitionFile,
" -m GTRCAT -T ", nthread, " -s ", input, " -n ",
output, sep="")
system(a)

# We use Dendroscope v.3.5.9 to root the tree to avoid any
# trouble between the node and the proper associated bootstrap
# values after re-rooting the tree we opened the RAxML tree including
# the bootstrap supports
# (‘RAxML_bipartitions.Concat_7GTR_Allconst_autoMRE_ReRooted’)
# in Dendroscope 3.5.9 (available at: http://dendroscope.org/),
# specifying that internal nodes should be interpreted as edge labels.
# Then the tree was re-rooted using the MRCA of "Halosauropsis_macrochir",
# Aldrovandia_affinis", "Bassanago_bulbiceps", and "Conger_verreauxi",
# all belong to the "outgroup" of Elopomorpha.

# Load the re-rooted tree in R (A rooted tree is available in the
# package and has been loaded in the temporary directory)
require(ape)
TreeRooted = read.nexus("TempDir.TopoConstraints2/RAxML_bipartitions.Concat_7GTR_Allconst_autoMRE_ReRooted")


#### Example restricted to taxa with at least a DNA sequence in the supermatrix.

# The input.xml file, called SimpleXml.xml, was prepare by Beauti, it is available
# in the folder "TempDir.TopoConstraints2/xmlfiles". This xml file includes
# the basic template of the xml file (including the supermatrix,
# the partions, the substitution and clock models, the priors,
# the MCMC parameters). However the hard constraints were not
# included in this input.xml file, but will be so by running the
# MultiTopoConst.EditXML4BEAST2 function below.

MultiTopoConst.EditXML4BEAST2(inputtree = TreeRooted,
output = "TempDir.TopoConstraints2/SimpleXml_Wcont.xml",
bootstrapTH = 100, xmltreename = "Subset1",
input.xml = "TempDir.TopoConstraints2/SimpleXml.xml",
Partitions = "TRUE")


#### Example including taxa without DNA in the supermatrix.

# Load a table with the new taxa without DNA and the topological constraint
# This table will be used to fill the option "TaxaNoDNA".
TaxaNoDNA = cbind(c("Titi_titi", "Toto_toto"), c("Family", "Genus"), c("Congridae", "Scorpaena"))
colnames(TaxaNoDNA) = c("SpeciesName", "hier.level", "ConstraintName")
TaxaNoDNA = as.data.frame(TaxaNoDNA)

# Load the classification table (the same that for the
# ConstraintTaxo2newick function), there are two way to do it:
# either through the .Rdata
data(TopoConstraints) # the second object of the list is the classification table
dim(TopoConstraints[[2]]) # 16 by 23.
# or the classification table has been loaded into the temporary directory,
# and can be loaded into the R environment doing the following
ClassifDF = read.csv("TempDir.TopoConstraints2/Classif16sp.csv", header = TRUE)
dim(ClassifDF) # 16 by 23


# Run the function, but this time the input.xml file called "SimpleXml_2SpNoDNA.xml"
# generated by Beauti must be selected. This xml file template was built using
# an alignment (called "Concat_2spNoDNA_PF2.nex") including two empty sequences
# (i.e. "Titi_titi, "Toto_toto") built by the Align.Concat function.
# This alignment has been completed by the nexus block related to the best
# partition scheme defined by partitionFinder2 (here we used the same
# partition scheme that the one defined for the 16 taxa with at least a DNA sequence).

MultiTopoConst.EditXML4BEAST2(inputtree = TreeRooted,
output = "TempDir.TopoConstraints2/SimpleXml_2SpNoDNA_Wcont.xml",
bootstrapTH = 100, xmltreename = "Subset1",
input.xml = "TempDir.TopoConstraints2/SimpleXml_2SpNoDNA.xml",
Partitions = "TRUE", TaxaNoDNA = TaxaNoDNA,
TaxoTable = ClassifDF,
output.new.TaxoTable = "TempDir.TopoConstraints2/Classif18sp_2NoDNA.csv",
output.new.tree = "TempDir.TopoConstraints2/BackboneTreeAll_2spNoDNA.txt")

# Plot the newly constrained tree including the 2 taxa without DNA
NewTree = read.tree("TempDir.TopoConstraints2/BackboneTreeAll_2spNoDNA.txt")
plot(NewTree)

# To see the new classification table including the 2 taxa without DNA.
NewClassifDF = read.delim("TempDir.TopoConstraints2/Classif18sp_2NoDNA.csv",
sep = "\\t", header = TRUE)
dim(NewClassifDF) # now there are 18 rows and still 23 columns.

# To clean the files created while running the example do the following:
unlink("TempDir.TopoConstraints2", recursive = TRUE)
a = list.files()
a1 = a[grep("Concat_7GTR_Allconst_autoMRE", a)]
file.remove(a1)

}


}
